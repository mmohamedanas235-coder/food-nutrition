# ============================================================
# ğŸ§‘â€ğŸ³ ResNet50 Training on Food-101 (Kaggle-Ready)
# ============================================================

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import models, transforms
from torchvision.datasets import Food101
from torch.utils.data import DataLoader
from tqdm import tqdm
import copy
import os

# ============================================================
# âš™ï¸ Configuration
# ============================================================
DATA_ROOT = "/kaggle/working/data"  # Use Kaggle's working directory
BATCH_SIZE = 32
NUM_EPOCHS = 5   # Increase to 10+ later for better accuracy
LR = 1e-4
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("ğŸ–¥ï¸ Device:", DEVICE)

# ============================================================
# ğŸ§¾ Data Transforms
# ============================================================
train_transform = transforms.Compose([
    transforms.RandomResizedCrop(224),
    transforms.RandomHorizontalFlip(),
    transforms.ColorJitter(0.2, 0.2, 0.2, 0.02),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225]),
])

val_transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406],
                         [0.229, 0.224, 0.225]),
])

# ============================================================
# ğŸ” Load Food-101 Dataset
# ============================================================
print("ğŸ“¦ Loading Food-101 dataset (this may take a few minutes)...")

train_ds = Food101(root=DATA_ROOT, split="train", download=True, transform=train_transform)
val_ds = Food101(root=DATA_ROOT, split="test", download=True, transform=val_transform)

train_loader = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True, num_workers=2)
val_loader = DataLoader(val_ds, batch_size=BATCH_SIZE, shuffle=False, num_workers=2)

print(f"âœ… Loaded {len(train_ds)} training and {len(val_ds)} validation samples.")
print(f"ğŸ“š Classes: {len(train_ds.classes)}")

# ============================================================
# ğŸ§  Model Setup (ResNet50)
# ============================================================
print("ğŸ”§ Initializing ResNet50 model...")

model = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)
model.fc = nn.Linear(model.fc.in_features, 101)  # Food-101 has 101 classes
model = model.to(DEVICE)

criterion = nn.CrossEntropyLoss()
optimizer = optim.AdamW(model.parameters(), lr=LR)

best_acc = 0.0
best_wts = copy.deepcopy(model.state_dict())

# ============================================================
# ğŸš€ Training Loop
# ============================================================
for epoch in range(NUM_EPOCHS):
    print(f"\nğŸŒŸ Epoch {epoch+1}/{NUM_EPOCHS}")
    print("-" * 40)

    # ---- Training ----
    model.train()
    running_loss = 0.0
    running_corrects = 0
    total = 0

    for imgs, labels in tqdm(train_loader, desc="Training", ncols=100):
        imgs, labels = imgs.to(DEVICE), labels.to(DEVICE)
        optimizer.zero_grad()
        outputs = model(imgs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        _, preds = torch.max(outputs, 1)
        running_loss += loss.item() * imgs.size(0)
        running_corrects += (preds == labels).sum().item()
        total += labels.size(0)

    train_loss = running_loss / total
    train_acc = running_corrects / total
    print(f"ğŸ§© Train Loss: {train_loss:.4f} | Train Acc: {train_acc:.4f}")

    # ---- Validation ----
    model.eval()
    val_corrects = 0
    val_total = 0
    with torch.no_grad():
        for imgs, labels in tqdm(val_loader, desc="Validating", ncols=100):
            imgs, labels = imgs.to(DEVICE), labels.to(DEVICE)
            outputs = model(imgs)
            _, preds = torch.max(outputs, 1)
            val_corrects += (preds == labels).sum().item()
            val_total += labels.size(0)

    val_acc = val_corrects / val_total
    print(f"ğŸ¯ Validation Accuracy: {val_acc:.4f}")

    # ---- Save Best Model ----
    if val_acc > best_acc:
        best_acc = val_acc
        best_wts = copy.deepcopy(model.state_dict())
        torch.save(best_wts, "resnet50model.pth")
        print("âœ… New best model saved!")

# ============================================================
# ğŸ Finalize Training
# ============================================================
model.load_state_dict(best_wts)
torch.save(model.state_dict(), "resnet50model_final.pth")
print("\nğŸ‰ Training complete!")
print(f"ğŸ† Best Validation Accuracy: {best_acc:.4f}")
print("ğŸ’¾ Model saved as resnet50model_final.pth in /kaggle/working/")

